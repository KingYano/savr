{"version":3,"file":"useFinance-BLxJwmk-.js","sources":["../../../shadcn-nuxt/utils.ts","../../../../components/ui/button/Button.vue","../../../../components/ui/button/index.ts","../../../../components/ui/input/Input.vue","../../../../stores/categories.ts","../../../../stores/movements.ts","../../../../stores/finance.ts","../../../../utils/database.ts","../../../../composables/useFinance.ts"],"sourcesContent":["import { type ClassValue, clsx } from 'clsx'\nimport { twMerge } from 'tailwind-merge'\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { Primitive, type PrimitiveProps } from 'reka-ui'\nimport { type ButtonVariants, buttonVariants } from '.'\n\ninterface Props extends PrimitiveProps {\n  variant?: ButtonVariants['variant']\n  size?: ButtonVariants['size']\n  class?: HTMLAttributes['class']\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  as: 'button',\n})\n</script>\n\n<template>\n  <Primitive\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :class=\"cn(buttonVariants({ variant, size }), props.class)\"\n  >\n    <slot />\n  </Primitive>\n</template>\n","import { cva, type VariantProps } from 'class-variance-authority'\n\nexport { default as Button } from './Button.vue'\n\nexport const buttonVariants = cva(\n  'inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0',\n  {\n    variants: {\n      variant: {\n        default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',\n        destructive:\n          'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',\n        outline:\n          'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',\n        secondary:\n          'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',\n        ghost: 'hover:bg-accent hover:text-accent-foreground',\n        link: 'text-primary underline-offset-4 hover:underline',\n      },\n      size: {\n        default: 'h-9 px-4 py-2',\n        xs: 'h-7 rounded px-2',\n        sm: 'h-8 rounded-md px-3 text-xs',\n        lg: 'h-10 rounded-md px-8',\n        icon: 'h-9 w-9',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  },\n)\n\nexport type ButtonVariants = VariantProps<typeof buttonVariants>\n","<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { useVModel } from '@vueuse/core'\n\nconst props = defineProps<{\n  defaultValue?: string | number\n  modelValue?: string | number\n  class?: HTMLAttributes['class']\n}>()\n\nconst emits = defineEmits<{\n  (e: 'update:modelValue', payload: string | number): void\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emits, {\n  passive: true,\n  defaultValue: props.defaultValue,\n})\n</script>\n\n<template>\n  <input v-model=\"modelValue\" :class=\"cn('flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50', props.class)\">\n</template>\n","import { defineStore } from 'pinia';\nimport type { Category, Tag, DEFAULT_CATEGORIES, CategoryStats } from '~/types/categories';\n\nexport interface CategoriesState {\n  categories: Category[];\n  tags: Tag[];\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport const useCategoriesStore = defineStore('categories', {\n  state: (): CategoriesState => ({\n    categories: [],\n    tags: [],\n    isLoading: false,\n    error: null\n  }),\n\n  getters: {\n    // Categories triées par ordre\n    sortedCategories: (state) => {\n      return [...state.categories].sort((a, b) => a.order - b.order);\n    },\n\n    // Categories par type (pour les revenus/dépenses)\n    expenseCategories: (state) => {\n      return state.categories.filter(cat => \n        cat.order < 10 // Les catégories de dépenses ont order < 10\n      );\n    },\n\n    incomeCategories: (state) => {\n      return state.categories.filter(cat => \n        cat.order >= 10 && cat.order < 90 // Les catégories de revenus ont order 10-89\n      );\n    },\n\n    // Categories avec sous-catégories\n    categoriesTree: (state) => {\n      const categories = state.categories;\n      const tree = categories.filter(cat => !cat.parentId);\n      \n      return tree.map(parent => ({\n        ...parent,\n        children: categories.filter(cat => cat.parentId === parent.id)\n      }));\n    },\n\n    // Options pour les selects\n    categoryOptions: (state) => {\n      return state.categories.map(cat => ({\n        value: cat.id,\n        label: cat.name,\n        icon: cat.icon,\n        color: cat.color,\n        description: cat.description\n      }));\n    },\n\n    tagOptions: (state) => {\n      return state.tags.map(tag => ({\n        value: tag.id,\n        label: tag.name,\n        color: tag.color\n      }));\n    },\n\n    // Recherche de catégorie par ID\n    getCategoryById: (state) => (id: string) => {\n      return state.categories.find(cat => cat.id === id);\n    },\n\n    // Recherche de tag par ID\n    getTagById: (state) => (id: string) => {\n      return state.tags.find(tag => tag.id === id);\n    },\n\n    // Categories par couleur (pour l'affichage)\n    categoriesByColor: (state) => {\n      const colorMap = new Map<string, Category[]>();\n      state.categories.forEach(cat => {\n        const existing = colorMap.get(cat.color) || [];\n        existing.push(cat);\n        colorMap.set(cat.color, existing);\n      });\n      return colorMap;\n    }\n  },\n\n  actions: {\n    // Initialiser avec les catégories par défaut\n    async initializeDefaultCategories() {\n      this.isLoading = true;\n      this.error = null;\n\n      try {\n        const { DEFAULT_CATEGORIES } = await import('~/types/categories');\n        \n        const defaultCategories: Category[] = DEFAULT_CATEGORIES.map((cat, index) => ({\n          ...cat,\n          id: `default-${index}`,\n          createdAt: new Date()\n        }));\n\n        this.categories = defaultCategories;\n      } catch (error) {\n        this.error = 'Impossible de charger les catégories par défaut';\n        console.error('Erreur initialisation catégories:', error);\n      } finally {\n        this.isLoading = false;\n      }\n    },\n\n    // Ajouter une catégorie\n    addCategory(categoryData: Omit<Category, 'id' | 'createdAt'>) {\n      this.error = null;\n\n      try {\n        const newCategory: Category = {\n          ...categoryData,\n          id: `custom-${Date.now()}`,\n          createdAt: new Date()\n        };\n\n        // Validation\n        if (!newCategory.name.trim()) {\n          throw new Error('Le nom de la catégorie est requis');\n        }\n\n        if (this.categories.some(cat => cat.name.toLowerCase() === newCategory.name.toLowerCase())) {\n          throw new Error('Une catégorie avec ce nom existe déjà');\n        }\n\n        this.categories.push(newCategory);\n        return newCategory;\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de l\\'ajout';\n        throw error;\n      }\n    },\n\n    // Mettre à jour une catégorie\n    updateCategory(id: string, updates: Partial<Category>) {\n      this.error = null;\n\n      try {\n        const index = this.categories.findIndex(cat => cat.id === id);\n        if (index === -1) {\n          throw new Error('Catégorie introuvable');\n        }\n\n        // Ne pas permettre la modification des catégories par défaut système\n        if (this.categories[index].isDefault && updates.isDefault === false) {\n          throw new Error('Impossible de modifier une catégorie système');\n        }\n\n        this.categories[index] = {\n          ...this.categories[index],\n          ...updates\n        };\n\n        return this.categories[index];\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de la mise à jour';\n        throw error;\n      }\n    },\n\n    // Supprimer une catégorie\n    deleteCategory(id: string) {\n      this.error = null;\n\n      try {\n        const category = this.categories.find(cat => cat.id === id);\n        if (!category) {\n          throw new Error('Catégorie introuvable');\n        }\n\n        if (category.isDefault) {\n          throw new Error('Impossible de supprimer une catégorie par défaut');\n        }\n\n        this.categories = this.categories.filter(cat => cat.id !== id);\n        return true;\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de la suppression';\n        throw error;\n      }\n    },\n\n    // Ajouter un tag\n    addTag(tagData: Omit<Tag, 'id' | 'createdAt'>) {\n      this.error = null;\n\n      try {\n        const newTag: Tag = {\n          ...tagData,\n          id: `tag-${Date.now()}`,\n          createdAt: new Date()\n        };\n\n        if (!newTag.name.trim()) {\n          throw new Error('Le nom du tag est requis');\n        }\n\n        if (this.tags.some(tag => tag.name.toLowerCase() === newTag.name.toLowerCase())) {\n          throw new Error('Un tag avec ce nom existe déjà');\n        }\n\n        this.tags.push(newTag);\n        return newTag;\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de l\\'ajout du tag';\n        throw error;\n      }\n    },\n\n    // Supprimer un tag\n    deleteTag(id: string) {\n      this.error = null;\n      this.tags = this.tags.filter(tag => tag.id !== id);\n    },\n\n    // Charger les données depuis le stockage\n    loadData(data: { categories: Category[]; tags: Tag[] }) {\n      this.isLoading = true;\n      this.error = null;\n\n      try {\n        this.categories = data.categories.map(cat => ({\n          ...cat,\n          createdAt: cat.createdAt instanceof Date ? cat.createdAt : new Date(cat.createdAt)\n        }));\n\n        this.tags = data.tags.map(tag => ({\n          ...tag,\n          createdAt: tag.createdAt instanceof Date ? tag.createdAt : new Date(tag.createdAt)\n        }));\n\n        // Si aucune catégorie, initialiser avec les défaults\n        if (this.categories.length === 0) {\n          this.initializeDefaultCategories();\n        }\n      } catch (error) {\n        this.error = 'Erreur lors du chargement des catégories';\n        this.categories = [];\n        this.tags = [];\n        this.initializeDefaultCategories();\n      } finally {\n        this.isLoading = false;\n      }\n    },\n\n    // Réinitialiser l'erreur\n    clearError() {\n      this.error = null;\n    },\n\n    // Obtenir les statistiques d'une catégorie\n    getCategoryStats(categoryId: string, movements: any[]): CategoryStats | null {\n      const category = this.getCategoryById(categoryId);\n      if (!category) return null;\n\n      const categoryMovements = movements.filter(m => m.categoryId === categoryId);\n      const totalAmount = categoryMovements.reduce((sum, m) => sum + Math.abs(m.amount), 0);\n      const allMovementsTotal = movements.reduce((sum, m) => sum + Math.abs(m.amount), 0);\n\n      return {\n        categoryId,\n        category,\n        totalAmount,\n        percentage: allMovementsTotal > 0 ? (totalAmount / allMovementsTotal) * 100 : 0,\n        movementCount: categoryMovements.length,\n        avgAmount: categoryMovements.length > 0 ? totalAmount / categoryMovements.length : 0,\n        trend: 'stable', // TODO: Calculer la tendance\n        trendPercentage: 0\n      };\n    }\n  }\n});","import { defineStore } from 'pinia';\nimport type { Movement, NewMovement } from '~/types/finance';\n\nexport interface MovementsState {\n  movements: Movement[];\n  isLoading: boolean;\n  error: string | null;\n}\n\nexport const useMovementsStore = defineStore('movements', {\n  state: (): MovementsState => ({\n    movements: [],\n    isLoading: false,\n    error: null\n  }),\n\n  getters: {\n    // Mouvements triés par date (plus récents en premier)\n    sortedMovements: (state) => {\n      return [...state.movements].sort((a, b) => {\n        const dateA = a.date instanceof Date ? a.date : new Date(a.date);\n        const dateB = b.date instanceof Date ? b.date : new Date(b.date);\n        return dateB.getTime() - dateA.getTime();\n      });\n    },\n\n    // Mouvements par type\n    expenseMovements: (state) => state.movements.filter(m => m.type === 'expense'),\n    incomeMovements: (state) => state.movements.filter(m => m.type === 'income'),\n    \n    // Mouvements récurrents\n    recurrentMovements: (state) => state.movements.filter(m => m.isRecurrent),\n\n    // Total des mouvements\n    totalMovements: (state) => state.movements.length,\n\n    // Mouvement par ID\n    getMovementById: (state) => (id: number) => state.movements.find(m => m.id === id)\n  },\n\n  actions: {\n    // Ajouter un mouvement\n    addMovement(newMovement: NewMovement): Movement {\n      this.error = null;\n      \n      try {\n        const date = typeof newMovement.date === 'string'\n          ? new Date(newMovement.date)\n          : newMovement.date;\n\n        if (isNaN(date.getTime())) {\n          throw new Error('Date invalide');\n        }\n\n        const movement: Movement = {\n          id: Date.now() + Math.random(), // ID plus unique\n          name: newMovement.name.trim(),\n          amount: Number(newMovement.amount),\n          date,\n          type: newMovement.type,\n          isRecurrent: newMovement.isRecurrent,\n          imageUrl: newMovement.imageUrl || undefined\n        };\n\n        // Validation\n        if (!movement.name) {\n          throw new Error('Le nom est requis');\n        }\n        if (movement.amount <= 0) {\n          throw new Error('Le montant doit être positif');\n        }\n\n        this.movements.push(movement);\n        return movement;\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de l\\'ajout';\n        throw error;\n      }\n    },\n\n    // Mettre à jour un mouvement\n    updateMovement(updatedMovement: Movement): boolean {\n      this.error = null;\n      \n      try {\n        const index = this.movements.findIndex(m => m.id === updatedMovement.id);\n        if (index === -1) {\n          throw new Error('Mouvement introuvable');\n        }\n\n        // Validation\n        if (!updatedMovement.name.trim()) {\n          throw new Error('Le nom est requis');\n        }\n        if (updatedMovement.amount <= 0) {\n          throw new Error('Le montant doit être positif');\n        }\n        if (isNaN(updatedMovement.date.getTime())) {\n          throw new Error('Date invalide');\n        }\n\n        this.movements[index] = {\n          ...updatedMovement,\n          name: updatedMovement.name.trim(),\n          amount: Number(updatedMovement.amount)\n        };\n\n        return true;\n      } catch (error) {\n        this.error = error instanceof Error ? error.message : 'Erreur lors de la mise à jour';\n        return false;\n      }\n    },\n\n    // Supprimer un mouvement\n    deleteMovement(id: number): boolean {\n      this.error = null;\n      \n      const index = this.movements.findIndex(m => m.id === id);\n      if (index === -1) {\n        this.error = 'Mouvement introuvable';\n        return false;\n      }\n\n      this.movements.splice(index, 1);\n      return true;\n    },\n\n    // Supprimer tous les mouvements\n    clearAllMovements() {\n      this.movements = [];\n      this.error = null;\n    },\n\n    // Charger les mouvements (pour la persistance)\n    loadMovements(movements: Movement[]) {\n      this.isLoading = true;\n      this.error = null;\n      \n      try {\n        // Validation et nettoyage des données\n        this.movements = movements.map(m => ({\n          ...m,\n          id: m.id || Date.now() + Math.random(), // S'assurer qu'il y a un ID\n          date: m.date instanceof Date ? m.date : new Date(m.date),\n          amount: Number(m.amount),\n          name: m.name?.trim() || '',\n          // Nettoyer les URLs blob\n          imageUrl: m.imageUrl && m.imageUrl.startsWith('blob:') ? undefined : m.imageUrl\n        })).filter(m => \n          m.id !== undefined &&\n          m.id !== null &&\n          m.name && \n          !isNaN(m.amount) && \n          m.amount > 0 && \n          !isNaN(m.date.getTime())\n        );\n      } catch (error) {\n        this.error = 'Erreur lors du chargement des données';\n        this.movements = [];\n      } finally {\n        this.isLoading = false;\n      }\n    },\n\n    // Réinitialiser l'état d'erreur\n    clearError() {\n      this.error = null;\n    }\n  }\n});","import { defineStore } from 'pinia';\nimport { useMovementsStore } from './movements';\nimport type { Movement } from '~/types/finance';\n\nexport interface FinanceCalculations {\n  totalBalance: number;\n  monthlyIncome: number;\n  monthlyExpenses: number;\n  monthlyBalance: number;\n  recurrentAmount: number;\n}\n\nexport const useFinanceStore = defineStore('finance', {\n  getters: {\n    // Générer les récurrences pour une période donnée\n    getMovementsWithRecurrences: () => {\n      return (startDate: Date, endDate: Date): Movement[] => {\n        const movementsStore = useMovementsStore();\n        \n        if (!startDate || !endDate || isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {\n          console.error('Dates invalides:', { startDate, endDate });\n          return [...movementsStore.movements];\n        }\n\n        try {\n          const result: Movement[] = [...movementsStore.movements];\n\n          movementsStore.recurrentMovements.forEach(movement => {\n            const originalDate = new Date(movement.date);\n            \n            if (isNaN(originalDate.getTime())) {\n              console.error('Date invalide pour le mouvement récurrent:', movement);\n              return;\n            }\n\n            let currentDate = new Date(originalDate);\n            currentDate.setMonth(currentDate.getMonth() + 1);\n\n            while (currentDate <= endDate) {\n              if (currentDate >= startDate) {\n                const clonedMovement: Movement = {\n                  ...movement,\n                  id: movement.id + currentDate.getTime(), // ID unique\n                  date: new Date(currentDate),\n                  isGeneratedRecurrence: true\n                };\n                result.push(clonedMovement);\n              }\n\n              currentDate = new Date(currentDate);\n              currentDate.setMonth(currentDate.getMonth() + 1);\n            }\n          });\n\n          return result;\n        } catch (error) {\n          console.error('Erreur lors de la génération des récurrences:', error);\n          return [...movementsStore.movements];\n        }\n      };\n    },\n\n    // Mouvements d'un mois spécifique\n    getMonthMovements: () => {\n      return (date: Date): Movement[] => {\n        if (!date || isNaN(date.getTime())) {\n          console.error('Date invalide:', date);\n          return [];\n        }\n\n        try {\n          const year = date.getFullYear();\n          const month = date.getMonth();\n          const startDate = new Date(year, month, 1);\n          const endDate = new Date(year, month + 1, 0);\n\n          const financeStore = useFinanceStore();\n          const allMovements = financeStore.getMovementsWithRecurrences(startDate, endDate);\n\n          return allMovements.filter(movement => {\n            const movementDate = movement.date instanceof Date\n              ? movement.date\n              : new Date(movement.date);\n\n            if (isNaN(movementDate.getTime())) {\n              return false;\n            }\n\n            return movementDate.getMonth() === date.getMonth() &&\n              movementDate.getFullYear() === date.getFullYear();\n          });\n        } catch (error) {\n          console.error('Erreur lors de la récupération des mouvements du mois:', error);\n          return [];\n        }\n      };\n    },\n\n    // Mouvements d'un jour spécifique\n    getDayMovements: () => {\n      return (date: Date): Movement[] => {\n        if (!date || isNaN(date.getTime())) {\n          console.error('Date invalide:', date);\n          return [];\n        }\n\n        try {\n          // Générer les récurrences pour les 6 prochains mois\n          const sixMonthsLater = new Date(date);\n          sixMonthsLater.setMonth(sixMonthsLater.getMonth() + 6);\n\n          const financeStore = useFinanceStore();\n          const allMovements = financeStore.getMovementsWithRecurrences(date, sixMonthsLater);\n\n          return allMovements.filter(movement => {\n            const movementDate = movement.date instanceof Date\n              ? movement.date\n              : new Date(movement.date);\n\n            if (isNaN(movementDate.getTime())) {\n              return false;\n            }\n\n            return movementDate.getDate() === date.getDate() &&\n              movementDate.getMonth() === date.getMonth() &&\n              movementDate.getFullYear() === date.getFullYear();\n          });\n        } catch (error) {\n          console.error('Erreur lors de la récupération des mouvements du jour:', error);\n          return [];\n        }\n      };\n    },\n\n    // Calculs financiers pour un mois\n    getMonthCalculations: () => {\n      return (date: Date): FinanceCalculations => {\n        const financeStore = useFinanceStore();\n        const monthMovements = financeStore.getMonthMovements(date);\n\n        const income = monthMovements\n          .filter(m => m.type === 'income')\n          .reduce((total, m) => total + Math.abs(m.amount), 0);\n\n        const expenses = monthMovements\n          .filter(m => m.type === 'expense')\n          .reduce((total, m) => total + Math.abs(m.amount), 0);\n\n        const recurrent = monthMovements\n          .filter(m => m.isRecurrent || m.isGeneratedRecurrence)\n          .reduce((total, m) => total + Math.abs(m.amount), 0);\n\n        return {\n          totalBalance: income - expenses,\n          monthlyIncome: income,\n          monthlyExpenses: expenses,\n          monthlyBalance: income - expenses,\n          recurrentAmount: recurrent\n        };\n      };\n    },\n\n    // Solde total général\n    getTotalBalance: () => {\n      const movementsStore = useMovementsStore();\n      return movementsStore.movements.reduce((total, movement) => {\n        const amount = movement.type === 'expense'\n          ? -Math.abs(movement.amount)\n          : Math.abs(movement.amount);\n        return total + amount;\n      }, 0);\n    }\n  }\n});","import Dexie, { type EntityTable } from 'dexie';\nimport type { Movement } from '~/types/finance';\nimport type { Category, Tag } from '~/types/categories';\n\nexport interface StoredMovement extends Omit<Movement, 'date'> {\n  date: string; // Stocké comme string pour IndexedDB\n}\n\nexport interface AppSettings {\n  id?: number;\n  key: string;\n  value: any;\n  updatedAt: Date;\n}\n\nexport interface StoredCategory {\n  id: string;\n  name: string;\n  icon: string;\n  color: string;\n  description?: string;\n  isDefault: boolean;\n  parentId?: string;\n  order: number;\n  createdAt: string;\n}\n\nexport interface StoredTag {\n  id: string;\n  name: string;\n  color: string;\n  createdAt: string;\n}\n\n// Base de données IndexedDB avec Dexie\nexport class SavrDatabase extends Dexie {\n  movements!: EntityTable<StoredMovement, 'id'>;\n  settings!: EntityTable<AppSettings, 'id'>;\n  categories!: EntityTable<StoredCategory, 'id'>;\n  tags!: EntityTable<StoredTag, 'id'>;\n\n  constructor() {\n    super('SavrDB');\n    \n    this.version(1).stores({\n      movements: 'id, name, amount, date, type, isRecurrent, imageUrl',\n      settings: '++id, key, value, updatedAt'\n    });\n\n    this.version(2).stores({\n      movements: 'id, name, amount, date, type, isRecurrent, imageUrl, isGeneratedRecurrence',\n      settings: '++id, key, value, updatedAt'\n    }).upgrade(tx => {\n      // Migration pour ajouter isGeneratedRecurrence\n      return tx.table('movements').toCollection().modify(movement => {\n        movement.isGeneratedRecurrence = false;\n      });\n    });\n\n    this.version(3).stores({\n      movements: 'id, name, amount, date, type, isRecurrent, imageUrl, isGeneratedRecurrence, categoryId',\n      settings: '++id, key, value, updatedAt',\n      categories: 'id, name, order, isDefault',\n      tags: 'id, name'\n    }).upgrade(tx => {\n      // Migration pour ajouter categoryId et tags aux mouvements\n      return tx.table('movements').toCollection().modify(movement => {\n        movement.categoryId = null;\n        movement.tags = [];\n        movement.description = null;\n      });\n    });\n  }\n}\n\n// Instance unique de la base de données\nexport const db = new SavrDatabase();\n\n// Service de gestion des mouvements\nexport class MovementsService {\n  // Sauvegarder tous les mouvements\n  static async saveMovements(movements: Movement[]): Promise<void> {\n    try {\n      const storedMovements: StoredMovement[] = movements.map(m => {\n        // S'assurer que date est un objet Date\n        const date = m.date instanceof Date ? m.date : new Date(m.date);\n        \n        return {\n          ...m,\n          date: date.toISOString()\n        };\n      });\n\n      await db.transaction('rw', db.movements, async () => {\n        await db.movements.clear();\n        await db.movements.bulkAdd(storedMovements);\n      });\n    } catch (error) {\n      console.error('Erreur sauvegarde mouvements:', error);\n      throw new Error('Impossible de sauvegarder les mouvements');\n    }\n  }\n\n  // Charger tous les mouvements\n  static async loadMovements(): Promise<Movement[]> {\n    try {\n      const storedMovements = await db.movements.toArray();\n      \n      return storedMovements.map(m => ({\n        ...m,\n        date: new Date(m.date)\n      }));\n    } catch (error) {\n      console.error('Erreur chargement mouvements:', error);\n      throw new Error('Impossible de charger les mouvements');\n    }\n  }\n\n  // Ajouter un mouvement\n  static async addMovement(movement: Movement): Promise<void> {\n    try {\n      const date = movement.date instanceof Date ? movement.date : new Date(movement.date);\n      \n      const storedMovement: StoredMovement = {\n        ...movement,\n        date: date.toISOString()\n      };\n\n      await db.movements.add(storedMovement);\n    } catch (error) {\n      console.error('Erreur ajout mouvement:', error);\n      throw new Error('Impossible d\\'ajouter le mouvement');\n    }\n  }\n\n  // Mettre à jour un mouvement\n  static async updateMovement(movement: Movement): Promise<void> {\n    try {\n      const date = movement.date instanceof Date ? movement.date : new Date(movement.date);\n      \n      const storedMovement: StoredMovement = {\n        ...movement,\n        date: date.toISOString()\n      };\n\n      await db.movements.update(movement.id, storedMovement);\n    } catch (error) {\n      console.error('Erreur mise à jour mouvement:', error);\n      throw new Error('Impossible de mettre à jour le mouvement');\n    }\n  }\n\n  // Supprimer un mouvement\n  static async deleteMovement(id: number): Promise<void> {\n    try {\n      await db.movements.delete(id);\n    } catch (error) {\n      console.error('Erreur suppression mouvement:', error);\n      throw new Error('Impossible de supprimer le mouvement');\n    }\n  }\n\n  // Vider tous les mouvements\n  static async clearAllMovements(): Promise<void> {\n    try {\n      await db.movements.clear();\n    } catch (error) {\n      console.error('Erreur vidage mouvements:', error);\n      throw new Error('Impossible de vider les mouvements');\n    }\n  }\n}\n\n// Service de gestion des paramètres\nexport class SettingsService {\n  // Sauvegarder un paramètre\n  static async saveSetting(key: string, value: any): Promise<void> {\n    try {\n      const existing = await db.settings.where('key').equals(key).first();\n      \n      const setting: AppSettings = {\n        key,\n        value,\n        updatedAt: new Date()\n      };\n\n      if (existing) {\n        await db.settings.update(existing.id!, setting);\n      } else {\n        await db.settings.add(setting);\n      }\n    } catch (error) {\n      console.error('Erreur sauvegarde paramètre:', error);\n      throw new Error(`Impossible de sauvegarder le paramètre ${key}`);\n    }\n  }\n\n  // Charger un paramètre\n  static async loadSetting<T>(key: string, defaultValue: T): Promise<T> {\n    try {\n      const setting = await db.settings.where('key').equals(key).first();\n      return setting ? setting.value : defaultValue;\n    } catch (error) {\n      console.error('Erreur chargement paramètre:', error);\n      return defaultValue;\n    }\n  }\n\n  // Charger tous les paramètres\n  static async loadAllSettings(): Promise<Record<string, any>> {\n    try {\n      const settings = await db.settings.toArray();\n      return settings.reduce((acc, setting) => {\n        acc[setting.key] = setting.value;\n        return acc;\n      }, {} as Record<string, any>);\n    } catch (error) {\n      console.error('Erreur chargement paramètres:', error);\n      return {};\n    }\n  }\n\n  // Supprimer un paramètre\n  static async deleteSetting(key: string): Promise<void> {\n    try {\n      await db.settings.where('key').equals(key).delete();\n    } catch (error) {\n      console.error('Erreur suppression paramètre:', error);\n      throw new Error(`Impossible de supprimer le paramètre ${key}`);\n    }\n  }\n}\n\n// Service de migration depuis localStorage\nexport class MigrationService {\n  // Migrer les données depuis localStorage\n  static async migrateFromLocalStorage(): Promise<{\n    movements: number;\n    settings: number;\n  }> {\n    if (!process.client) {\n      return { movements: 0, settings: 0 };\n    }\n\n    let migratedMovements = 0;\n    let migratedSettings = 0;\n\n    try {\n      // Migration des mouvements\n      const storedMovements = localStorage.getItem('financeMovements');\n      if (storedMovements) {\n        const movements: Movement[] = JSON.parse(storedMovements);\n        await MovementsService.saveMovements(movements);\n        migratedMovements = movements.length;\n        localStorage.removeItem('financeMovements');\n      }\n\n      // Migration des paramètres utilisateur\n      const storedSettings = localStorage.getItem('userSettings');\n      if (storedSettings) {\n        const settings = JSON.parse(storedSettings);\n        for (const [key, value] of Object.entries(settings)) {\n          await SettingsService.saveSetting(key, value);\n          migratedSettings++;\n        }\n        localStorage.removeItem('userSettings');\n      }\n\n      console.log(`Migration terminée: ${migratedMovements} mouvements, ${migratedSettings} paramètres`);\n      \n      return { movements: migratedMovements, settings: migratedSettings };\n    } catch (error) {\n      console.error('Erreur lors de la migration:', error);\n      throw new Error('Échec de la migration des données');\n    }\n  }\n\n  // Vérifier si une migration est nécessaire\n  static needsMigration(): boolean {\n    if (!process.client) return false;\n    \n    return !!(\n      localStorage.getItem('financeMovements') ||\n      localStorage.getItem('userSettings')\n    );\n  }\n\n  // Exporter toutes les données pour sauvegarde\n  static async exportData(): Promise<{\n    movements: Movement[];\n    settings: Record<string, any>;\n    exportDate: string;\n    version: string;\n  }> {\n    try {\n      const movements = await MovementsService.loadMovements();\n      const settings = await SettingsService.loadAllSettings();\n\n      return {\n        movements,\n        settings,\n        exportDate: new Date().toISOString(),\n        version: '1.0'\n      };\n    } catch (error) {\n      console.error('Erreur export données:', error);\n      throw new Error('Impossible d\\'exporter les données');\n    }\n  }\n\n  // Importer des données depuis une sauvegarde\n  static async importData(data: {\n    movements: Movement[];\n    settings: Record<string, any>;\n  }): Promise<void> {\n    try {\n      await db.transaction('rw', [db.movements, db.settings], async () => {\n        // Sauvegarder les mouvements\n        if (data.movements?.length) {\n          await MovementsService.saveMovements(data.movements);\n        }\n\n        // Sauvegarder les paramètres\n        if (data.settings) {\n          for (const [key, value] of Object.entries(data.settings)) {\n            await SettingsService.saveSetting(key, value);\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Erreur import données:', error);\n      throw new Error('Impossible d\\'importer les données');\n    }\n  }\n}\n\n// Service de gestion des catégories\nexport class CategoriesService {\n  // Sauvegarder toutes les catégories\n  static async saveCategories(categories: Category[]): Promise<void> {\n    try {\n      const storedCategories: StoredCategory[] = categories.map(cat => ({\n        ...cat,\n        createdAt: cat.createdAt.toISOString()\n      }));\n\n      await db.transaction('rw', db.categories, async () => {\n        await db.categories.clear();\n        await db.categories.bulkAdd(storedCategories);\n      });\n    } catch (error) {\n      console.error('Erreur sauvegarde catégories:', error);\n      throw new Error('Impossible de sauvegarder les catégories');\n    }\n  }\n\n  // Charger toutes les catégories\n  static async loadCategories(): Promise<Category[]> {\n    try {\n      const storedCategories = await db.categories.toArray();\n      \n      return storedCategories.map(cat => ({\n        ...cat,\n        createdAt: new Date(cat.createdAt)\n      }));\n    } catch (error) {\n      console.error('Erreur chargement catégories:', error);\n      return [];\n    }\n  }\n\n  // Sauvegarder tous les tags\n  static async saveTags(tags: Tag[]): Promise<void> {\n    try {\n      const storedTags: StoredTag[] = tags.map(tag => ({\n        ...tag,\n        createdAt: tag.createdAt.toISOString()\n      }));\n\n      await db.transaction('rw', db.tags, async () => {\n        await db.tags.clear();\n        await db.tags.bulkAdd(storedTags);\n      });\n    } catch (error) {\n      console.error('Erreur sauvegarde tags:', error);\n      throw new Error('Impossible de sauvegarder les tags');\n    }\n  }\n\n  // Charger tous les tags\n  static async loadTags(): Promise<Tag[]> {\n    try {\n      const storedTags = await db.tags.toArray();\n      \n      return storedTags.map(tag => ({\n        ...tag,\n        createdAt: new Date(tag.createdAt)\n      }));\n    } catch (error) {\n      console.error('Erreur chargement tags:', error);\n      return [];\n    }\n  }\n}","import { storeToRefs } from 'pinia';\nimport { useMovementsStore } from '~/stores/movements';\nimport { useFinanceStore } from '~/stores/finance';\nimport { useUIStore } from '~/stores/ui';\nimport { MovementsService, MigrationService } from '~/utils/database';\nimport type { Movement, NewMovement } from '~/types/finance';\n\n/**\n * Composable principal pour la gestion financière\n * Fait le pont entre les stores Pinia et les composants\n */\nexport function useFinance() {\n  const movementsStore = useMovementsStore();\n  const financeStore = useFinanceStore();\n  const uiStore = useUIStore();\n\n  // Refs réactives depuis les stores\n  const { movements, isLoading, error } = storeToRefs(movementsStore);\n\n  // Initialisation manuelle des données (pour les cas spéciaux)\n  const initializeData = async () => {\n    try {\n      uiStore.setLoading(true, 'Rechargement des données...');\n      const loadedMovements = await MovementsService.loadMovements();\n      movementsStore.loadMovements(loadedMovements);\n    } catch (error) {\n      console.error('Erreur initialisation:', error);\n      uiStore.showError(\n        'Erreur de chargement',\n        'Impossible de charger vos données.'\n      );\n    } finally {\n      uiStore.setLoading(false);\n    }\n  };\n\n  // Sauvegarder automatiquement après chaque modification\n  const autoSave = async () => {\n    try {\n      await MovementsService.saveMovements(movements.value);\n    } catch (error) {\n      console.error('Erreur sauvegarde automatique:', error);\n      uiStore.showError(\n        'Erreur de sauvegarde',\n        'Vos modifications n\\'ont pas pu être sauvegardées automatiquement.'\n      );\n    }\n  };\n\n  // Ajouter un mouvement\n  const addMovement = async (newMovement: NewMovement): Promise<boolean> => {\n    try {\n      uiStore.clearNotifications();\n      const movement = movementsStore.addMovement(newMovement);\n      await autoSave();\n      \n      uiStore.showSuccess('Mouvement ajouté', `${movement.name} a été ajouté avec succès`);\n      return true;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Erreur inconnue';\n      uiStore.showError('Erreur d\\'ajout', message);\n      return false;\n    }\n  };\n\n  // Mettre à jour un mouvement\n  const updateMovement = async (updatedMovement: Movement): Promise<boolean> => {\n    try {\n      uiStore.clearNotifications();\n      const success = movementsStore.updateMovement(updatedMovement);\n      \n      if (success) {\n        await autoSave();\n        uiStore.showSuccess('Mouvement modifié', 'Les modifications ont été sauvegardées');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Erreur inconnue';\n      uiStore.showError('Erreur de modification', message);\n      return false;\n    }\n  };\n\n  // Supprimer un mouvement\n  const deleteMovement = async (id: number): Promise<boolean> => {\n    try {\n      uiStore.clearNotifications();\n      const success = movementsStore.deleteMovement(id);\n      \n      if (success) {\n        await autoSave();\n        uiStore.showSuccess('Mouvement supprimé', 'Le mouvement a été supprimé avec succès');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Erreur inconnue';\n      uiStore.showError('Erreur de suppression', message);\n      return false;\n    }\n  };\n\n  // Fonctions de calcul (délégation au store finance)\n  const getMonthMovements = (date: Date) => financeStore.getMonthMovements(date);\n  const getDayMovements = (date: Date) => financeStore.getDayMovements(date);\n  const getMonthBalance = (date: Date) => financeStore.getMonthCalculations(date).monthlyBalance;\n  const getIncomeExpenseForMonth = (date: Date) => {\n    const calc = financeStore.getMonthCalculations(date);\n    return {\n      income: calc.monthlyIncome,\n      expense: calc.monthlyExpenses\n    };\n  };\n\n  // Fonctions utilitaires\n  const getTotalBalance = () => financeStore.getTotalBalance;\n\n  const exportData = async () => {\n    try {\n      uiStore.setLoading(true, 'Export en cours...');\n      const data = await MigrationService.exportData();\n      \n      // Créer un fichier de téléchargement\n      const blob = new Blob([JSON.stringify(data, null, 2)], { \n        type: 'application/json' \n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `savr-backup-${new Date().toISOString().split('T')[0]}.json`;\n      a.click();\n      URL.revokeObjectURL(url);\n      \n      uiStore.showSuccess('Export réussi', 'Vos données ont été exportées avec succès');\n    } catch (error) {\n      uiStore.showError('Erreur d\\'export', 'Impossible d\\'exporter vos données');\n    } finally {\n      uiStore.setLoading(false);\n    }\n  };\n\n  const importData = async (file: File) => {\n    try {\n      uiStore.setLoading(true, 'Import en cours...');\n      \n      const text = await file.text();\n      const data = JSON.parse(text);\n      \n      await MigrationService.importData(data);\n      await initializeData(); // Recharger les données\n      \n      uiStore.showSuccess('Import réussi', 'Vos données ont été importées avec succès');\n    } catch (error) {\n      uiStore.showError('Erreur d\\'import', 'Format de fichier invalide ou données corrompues');\n    } finally {\n      uiStore.setLoading(false);\n    }\n  };\n\n  // L'initialisation est maintenant gérée par le plugin pinia.client.ts\n\n  return {\n    // État\n    movements: readonly(movements),\n    isLoading: readonly(isLoading),\n    error: readonly(error),\n\n    // Actions\n    addMovement,\n    updateMovement,\n    deleteMovement,\n\n    // Calculs\n    getMonthMovements,\n    getDayMovements,\n    getMonthBalance,\n    getIncomeExpenseForMonth,\n    getTotalBalance,\n\n    // Utilitaires\n    initializeData,\n    exportData,\n    importData\n  };\n}"],"names":["error"],"mappings":"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"}